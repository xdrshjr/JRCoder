# 05-æ—¥å¿—ä¸å¯è§†åŒ–è®¾è®¡

## 1. æ—¥å¿—ç³»ç»Ÿæ¦‚è¿°

æ—¥å¿—ç³»ç»Ÿè´Ÿè´£è®°å½• Agent æ‰§è¡Œè¿‡ç¨‹ä¸­çš„æ‰€æœ‰å…³é”®ä¿¡æ¯ï¼ŒåŒ…æ‹¬ LLM è°ƒç”¨ã€å·¥å…·æ‰§è¡Œã€çŠ¶æ€å˜åŒ–ç­‰ï¼Œä¸ºè°ƒè¯•ã€å®¡è®¡å’Œæ€§èƒ½åˆ†ææä¾›æ”¯æŒã€‚

### 1.1 è®¾è®¡ç›®æ ‡
- **å®Œæ•´æ€§**: è®°å½•æ‰€æœ‰å…³é”®æ“ä½œå’Œå†³ç­–
- **ç»“æ„åŒ–**: ä½¿ç”¨ JSON æ ¼å¼ä¾¿äºè§£æå’Œåˆ†æ
- **å¯è¯»æ€§**: æ§åˆ¶å°è¾“å‡ºå‹å¥½ï¼Œä¾¿äºå®æ—¶ç›‘æ§
- **æ€§èƒ½**: å¼‚æ­¥å†™å…¥ï¼Œä¸é˜»å¡ä¸»æµç¨‹
- **å¯é…ç½®**: æ”¯æŒå¤šçº§åˆ«ã€å¤šè¾“å‡ºç›®æ ‡

## 2. æ—¥å¿—æ¶æ„

### 2.1 æ—¥å¿—å±‚çº§

```typescript
enum LogLevel {
  DEBUG = 0,   // è¯¦ç»†è°ƒè¯•ä¿¡æ¯
  INFO = 1,    // ä¸€èˆ¬ä¿¡æ¯
  WARN = 2,    // è­¦å‘Šä¿¡æ¯
  ERROR = 3    // é”™è¯¯ä¿¡æ¯
}

const LOG_LEVEL_NAMES = {
  [LogLevel.DEBUG]: 'DEBUG',
  [LogLevel.INFO]: 'INFO',
  [LogLevel.WARN]: 'WARN',
  [LogLevel.ERROR]: 'ERROR'
};
```

### 2.2 æ—¥å¿—è®°å½•å™¨å®ç°

```typescript
import winston from 'winston';
import chalk from 'chalk';

class Logger implements ILogger {
  private winstonLogger: winston.Logger;
  private context: Record<string, any> = {};

  constructor(config: GlobalConfig['logging']) {
    // åˆ›å»º Winston Logger
    this.winstonLogger = winston.createLogger({
      level: config.level,
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      transports: this.createTransports(config)
    });
  }

  // åˆ›å»ºæ—¥å¿—è¾“å‡ºç›®æ ‡
  private createTransports(config: GlobalConfig['logging']): winston.transport[] {
    const transports: winston.transport[] = [];

    // æ§åˆ¶å°è¾“å‡º
    if (config.enableConsole) {
      transports.push(
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.printf(this.consoleFormat.bind(this))
          )
        })
      );
    }

    // æ–‡ä»¶è¾“å‡º
    if (config.enableFile) {
      // æ‰€æœ‰æ—¥å¿—
      transports.push(
        new winston.transports.File({
          filename: path.join(config.outputDir, 'combined.log'),
          maxsize: config.maxFileSize,
          maxFiles: config.maxFiles
        })
      );

      // é”™è¯¯æ—¥å¿—
      transports.push(
        new winston.transports.File({
          filename: path.join(config.outputDir, 'error.log'),
          level: 'error',
          maxsize: config.maxFileSize,
          maxFiles: config.maxFiles
        })
      );
    }

    return transports;
  }

  // æ§åˆ¶å°æ ¼å¼åŒ–
  private consoleFormat(info: any): string {
    const { timestamp, level, message, ...meta } = info;
    const time = new Date(timestamp).toLocaleTimeString();

    let output = `${chalk.gray(time)} ${level}: ${message}`;

    // æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
    if (this.context && Object.keys(this.context).length > 0) {
      output += chalk.gray(` [${JSON.stringify(this.context)}]`);
    }

    // æ·»åŠ é¢å¤–æ•°æ®
    if (Object.keys(meta).length > 0) {
      output += `\n${chalk.gray(JSON.stringify(meta, null, 2))}`;
    }

    return output;
  }

  // åŸºç¡€æ—¥å¿—æ–¹æ³•
  debug(message: string, data?: any): void {
    this.winstonLogger.debug(message, { ...this.context, ...data });
  }

  info(message: string, data?: any): void {
    this.winstonLogger.info(message, { ...this.context, ...data });
  }

  warn(message: string, data?: any): void {
    this.winstonLogger.warn(message, { ...this.context, ...data });
  }

  error(message: string, error?: Error, data?: any): void {
    this.winstonLogger.error(message, {
      ...this.context,
      ...data,
      error: error ? {
        message: error.message,
        stack: error.stack,
        name: error.name
      } : undefined
    });
  }

  // ç‰¹æ®Šæ—¥å¿—æ–¹æ³•
  logToolCall(toolName: string, args: any): void {
    this.info(`Tool called: ${toolName}`, {
      type: 'tool_call',
      toolName,
      arguments: args
    });
  }

  logToolResult(toolName: string, result: ToolResult): void {
    if (result.success) {
      this.info(`Tool completed: ${toolName}`, {
        type: 'tool_result',
        toolName,
        success: true,
        executionTime: result.metadata?.executionTime
      });
    } else {
      this.error(`Tool failed: ${toolName}`, undefined, {
        type: 'tool_result',
        toolName,
        success: false,
        error: result.error
      });
    }
  }

  logLLMRequest(request: LLMRequest): void {
    this.debug('LLM request', {
      type: 'llm_request',
      messageCount: request.messages.length,
      toolCount: request.tools?.length || 0,
      temperature: request.temperature,
      maxTokens: request.maxTokens
    });
  }

  logLLMResponse(response: LLMResponse): void {
    this.info('LLM response', {
      type: 'llm_response',
      finishReason: response.finishReason,
      toolCalls: response.toolCalls?.length || 0,
      usage: response.usage
    });
  }

  // åˆ›å»ºå­æ—¥å¿—å™¨ï¼ˆå¸¦ä¸Šä¸‹æ–‡ï¼‰
  child(context: Record<string, any>): Logger {
    const childLogger = new Logger(this.winstonLogger.transports[0] as any);
    childLogger.context = { ...this.context, ...context };
    childLogger.winstonLogger = this.winstonLogger;
    return childLogger;
  }
}
```

## 3. CLI å¯è§†åŒ–

### 3.1 è¿›åº¦æ˜¾ç¤º

```typescript
import ora from 'ora';
import cliProgress from 'cli-progress';

class ProgressDisplay {
  private spinner: ora.Ora;
  private progressBar: cliProgress.SingleBar;

  // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
  showSpinner(message: string): void {
    this.spinner = ora({
      text: message,
      spinner: 'dots',
      color: 'cyan'
    }).start();
  }

  // æ›´æ–°åŠ è½½åŠ¨ç”»
  updateSpinner(message: string): void {
    if (this.spinner) {
      this.spinner.text = message;
    }
  }

  // åœæ­¢åŠ è½½åŠ¨ç”»ï¼ˆæˆåŠŸï¼‰
  succeedSpinner(message?: string): void {
    if (this.spinner) {
      this.spinner.succeed(message);
      this.spinner = null;
    }
  }

  // åœæ­¢åŠ è½½åŠ¨ç”»ï¼ˆå¤±è´¥ï¼‰
  failSpinner(message?: string): void {
    if (this.spinner) {
      this.spinner.fail(message);
      this.spinner = null;
    }
  }

  // æ˜¾ç¤ºè¿›åº¦æ¡
  showProgressBar(total: number, message: string): void {
    this.progressBar = new cliProgress.SingleBar({
      format: `${message} |${chalk.cyan('{bar}')}| {percentage}% | {value}/{total} tasks`,
      barCompleteChar: '\u2588',
      barIncompleteChar: '\u2591',
      hideCursor: true
    });

    this.progressBar.start(total, 0);
  }

  // æ›´æ–°è¿›åº¦æ¡
  updateProgressBar(current: number): void {
    if (this.progressBar) {
      this.progressBar.update(current);
    }
  }

  // åœæ­¢è¿›åº¦æ¡
  stopProgressBar(): void {
    if (this.progressBar) {
      this.progressBar.stop();
      this.progressBar = null;
    }
  }
}
```

### 3.2 é˜¶æ®µæ˜¾ç¤º

```typescript
class PhaseDisplay {
  private currentPhase: AgentPhase;

  // æ˜¾ç¤ºé˜¶æ®µå˜åŒ–
  showPhase(phase: AgentPhase): void {
    this.currentPhase = phase;

    const phaseIcons = {
      planning: 'ğŸ“‹',
      executing: 'âš™ï¸',
      reflecting: 'ğŸ¤”',
      confirming: 'â“',
      completed: 'âœ…',
      failed: 'âŒ'
    };

    const phaseNames = {
      planning: 'Planning',
      executing: 'Executing',
      reflecting: 'Reflecting',
      confirming: 'Confirming',
      completed: 'Completed',
      failed: 'Failed'
    };

    console.log(
      chalk.bold(`\n${phaseIcons[phase]} ${phaseNames[phase]}\n`)
    );
  }

  // æ˜¾ç¤ºä»»åŠ¡åˆ—è¡¨
  showTasks(plan: Plan): void {
    console.log(chalk.bold('\nğŸ“‹ Tasks:\n'));

    plan.tasks.forEach((task, index) => {
      const statusIcon = {
        pending: 'â³',
        in_progress: 'ğŸ”„',
        completed: 'âœ…',
        failed: 'âŒ',
        blocked: 'ğŸš«'
      }[task.status];

      const statusColor = {
        pending: chalk.gray,
        in_progress: chalk.cyan,
        completed: chalk.green,
        failed: chalk.red,
        blocked: chalk.yellow
      }[task.status];

      console.log(
        statusColor(`${index + 1}. ${statusIcon} ${task.title}`)
      );

      if (task.description) {
        console.log(chalk.gray(`   ${task.description}`));
      }
    });

    console.log();
  }

  // æ˜¾ç¤ºæ‰§è¡Œæ‘˜è¦
  showSummary(state: AgentState): void {
    console.log(chalk.bold('\nğŸ“Š Execution Summary\n'));

    const completedTasks = state.plan.tasks.filter(t => t.status === 'completed').length;
    const totalTasks = state.plan.tasks.length;

    console.log(chalk.cyan(`Tasks: ${completedTasks}/${totalTasks} completed`));
    console.log(chalk.cyan(`Iterations: ${state.currentIteration}/${state.maxIterations}`));
    console.log(chalk.cyan(`Total tokens: ${state.metadata.totalTokens}`));
    console.log(chalk.cyan(`Total cost: $${state.metadata.totalCost.toFixed(4)}`));
    console.log(chalk.cyan(`Tool calls: ${state.metadata.toolCallsCount}`));

    const duration = state.endTime ? state.endTime - state.startTime : Date.now() - state.startTime;
    console.log(chalk.cyan(`Duration: ${(duration / 1000).toFixed(2)}s`));

    console.log();
  }
}
```

### 3.3 å®æ—¶æ—¥å¿—æµ

```typescript
class LogStream {
  private buffer: LogEntry[] = [];
  private maxBufferSize = 100;

  // æ·»åŠ æ—¥å¿—æ¡ç›®
  add(entry: LogEntry): void {
    this.buffer.push(entry);

    // é™åˆ¶ç¼“å†²åŒºå¤§å°
    if (this.buffer.length > this.maxBufferSize) {
      this.buffer.shift();
    }

    // å®æ—¶æ˜¾ç¤º
    this.display(entry);
  }

  // æ˜¾ç¤ºæ—¥å¿—æ¡ç›®
  private display(entry: LogEntry): void {
    const time = new Date(entry.timestamp).toLocaleTimeString();
    const levelColor = {
      debug: chalk.gray,
      info: chalk.cyan,
      warn: chalk.yellow,
      error: chalk.red
    }[entry.level];

    let output = `${chalk.gray(time)} ${levelColor(entry.level.toUpperCase())}: ${entry.message}`;

    // æ˜¾ç¤ºä¸Šä¸‹æ–‡
    if (entry.context) {
      const contextStr = Object.entries(entry.context)
        .map(([k, v]) => `${k}=${v}`)
        .join(' ');
      output += chalk.gray(` [${contextStr}]`);
    }

    console.log(output);

    // æ˜¾ç¤ºè¯¦ç»†æ•°æ®ï¼ˆä»… debug çº§åˆ«ï¼‰
    if (entry.level === 'debug' && entry.data) {
      console.log(chalk.gray(JSON.stringify(entry.data, null, 2)));
    }
  }

  // è·å–æœ€è¿‘çš„æ—¥å¿—
  getRecent(count: number = 10): LogEntry[] {
    return this.buffer.slice(-count);
  }

  // æ¸…ç©ºç¼“å†²åŒº
  clear(): void {
    this.buffer = [];
  }
}
```

## 4. æ‰§è¡ŒæŠ¥å‘Šç”Ÿæˆ

### 4.1 æŠ¥å‘Šç”Ÿæˆå™¨

```typescript
class ReportGenerator {
  // ç”Ÿæˆ Markdown æŠ¥å‘Š
  generateMarkdown(state: AgentState): string {
    const report: string[] = [];

    // æ ‡é¢˜
    report.push('# Agent Execution Report\n');
    report.push(`**Generated at**: ${new Date().toISOString()}\n`);

    // æ¦‚è§ˆ
    report.push('## Overview\n');
    report.push(`- **Goal**: ${state.plan.goal}`);
    report.push(`- **Status**: ${state.phase}`);
    report.push(`- **Iterations**: ${state.currentIteration}/${state.maxIterations}`);
    report.push(`- **Duration**: ${this.formatDuration(state.endTime - state.startTime)}`);
    report.push('');

    // ç»Ÿè®¡
    report.push('## Statistics\n');
    report.push(`- **Total tokens**: ${state.metadata.totalTokens}`);
    report.push(`- **Total cost**: $${state.metadata.totalCost.toFixed(4)}`);
    report.push(`- **Tool calls**: ${state.metadata.toolCallsCount}`);
    report.push('');

    // ä»»åŠ¡åˆ—è¡¨
    report.push('## Tasks\n');
    state.plan.tasks.forEach((task, index) => {
      const statusEmoji = {
        pending: 'â³',
        in_progress: 'ğŸ”„',
        completed: 'âœ…',
        failed: 'âŒ',
        blocked: 'ğŸš«'
      }[task.status];

      report.push(`### ${index + 1}. ${statusEmoji} ${task.title}\n`);
      report.push(`**Status**: ${task.status}`);
      report.push(`**Description**: ${task.description}`);

      if (task.result) {
        report.push(`**Result**: ${task.result}`);
      }

      if (task.error) {
        report.push(`**Error**: ${task.error}`);
      }

      report.push('');
    });

    // å¯¹è¯å†å²
    report.push('## Conversation History\n');
    state.conversation.messages.forEach((msg, index) => {
      report.push(`### Message ${index + 1}\n`);
      report.push(`**Role**: ${msg.role}`);
      report.push(`**Timestamp**: ${new Date(msg.timestamp).toISOString()}`);
      report.push('```');
      report.push(msg.content);
      report.push('```');
      report.push('');
    });

    return report.join('\n');
  }

  // ç”Ÿæˆ JSON æŠ¥å‘Š
  generateJSON(state: AgentState): string {
    return JSON.stringify(state, null, 2);
  }

  // ç”Ÿæˆ HTML æŠ¥å‘Š
  generateHTML(state: AgentState): string {
    const markdown = this.generateMarkdown(state);
    // ä½¿ç”¨ marked åº“å°† Markdown è½¬æ¢ä¸º HTML
    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Agent Execution Report</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
    h1 { color: #333; }
    h2 { color: #666; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
    code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
    pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
    .status-completed { color: green; }
    .status-failed { color: red; }
    .status-pending { color: gray; }
  </style>
</head>
<body>
  ${marked(markdown)}
</body>
</html>
    `;
  }

  // æ ¼å¼åŒ–æŒç»­æ—¶é—´
  private formatDuration(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }

  // ä¿å­˜æŠ¥å‘Š
  async save(state: AgentState, format: 'markdown' | 'json' | 'html'): Promise<string> {
    const timestamp = Date.now();
    const filename = `report-${timestamp}.${format === 'markdown' ? 'md' : format}`;
    const filepath = path.join('logs', filename);

    let content: string;
    switch (format) {
      case 'markdown':
        content = this.generateMarkdown(state);
        break;
      case 'json':
        content = this.generateJSON(state);
        break;
      case 'html':
        content = this.generateHTML(state);
        break;
    }

    await fs.writeFile(filepath, content, 'utf8');
    return filepath;
  }
}
```

## 5. æ—¥å¿—åˆ†æå·¥å…·

### 5.1 æ—¥å¿—è§£æå™¨

```typescript
class LogAnalyzer {
  // è§£ææ—¥å¿—æ–‡ä»¶
  async parseLogFile(filepath: string): Promise<LogEntry[]> {
    const content = await fs.readFile(filepath, 'utf8');
    const lines = content.split('\n').filter(line => line.trim());

    return lines.map(line => {
      try {
        return JSON.parse(line) as LogEntry;
      } catch {
        return null;
      }
    }).filter(entry => entry !== null);
  }

  // ç»Ÿè®¡åˆ†æ
  analyze(entries: LogEntry[]): LogAnalysis {
    const analysis: LogAnalysis = {
      totalEntries: entries.length,
      byLevel: { debug: 0, info: 0, warn: 0, error: 0 },
      byType: {},
      toolCalls: [],
      llmCalls: [],
      errors: [],
      timeline: []
    };

    for (const entry of entries) {
      // æŒ‰çº§åˆ«ç»Ÿè®¡
      analysis.byLevel[entry.level]++;

      // æŒ‰ç±»å‹ç»Ÿè®¡
      if (entry.context?.type) {
        const type = entry.context.type;
        analysis.byType[type] = (analysis.byType[type] || 0) + 1;
      }

      // æå–å·¥å…·è°ƒç”¨
      if (entry.context?.type === 'tool_call') {
        analysis.toolCalls.push({
          toolName: entry.context.toolName,
          timestamp: entry.timestamp,
          arguments: entry.data
        });
      }

      // æå– LLM è°ƒç”¨
      if (entry.context?.type === 'llm_response') {
        analysis.llmCalls.push({
          timestamp: entry.timestamp,
          usage: entry.data?.usage
        });
      }

      // æå–é”™è¯¯
      if (entry.level === 'error') {
        analysis.errors.push({
          message: entry.message,
          timestamp: entry.timestamp,
          error: entry.data?.error
        });
      }

      // æ„å»ºæ—¶é—´çº¿
      analysis.timeline.push({
        timestamp: entry.timestamp,
        level: entry.level,
        message: entry.message
      });
    }

    return analysis;
  }

  // ç”Ÿæˆåˆ†ææŠ¥å‘Š
  generateAnalysisReport(analysis: LogAnalysis): string {
    const report: string[] = [];

    report.push('# Log Analysis Report\n');

    // æ€»ä½“ç»Ÿè®¡
    report.push('## Overall Statistics\n');
    report.push(`- Total entries: ${analysis.totalEntries}`);
    report.push(`- Debug: ${analysis.byLevel.debug}`);
    report.push(`- Info: ${analysis.byLevel.info}`);
    report.push(`- Warn: ${analysis.byLevel.warn}`);
    report.push(`- Error: ${analysis.byLevel.error}`);
    report.push('');

    // å·¥å…·è°ƒç”¨ç»Ÿè®¡
    report.push('## Tool Calls\n');
    const toolStats = this.groupBy(analysis.toolCalls, 'toolName');
    for (const [tool, calls] of Object.entries(toolStats)) {
      report.push(`- ${tool}: ${calls.length} calls`);
    }
    report.push('');

    // LLM è°ƒç”¨ç»Ÿè®¡
    report.push('## LLM Calls\n');
    const totalTokens = analysis.llmCalls.reduce(
      (sum, call) => sum + (call.usage?.totalTokens || 0),
      0
    );
    report.push(`- Total calls: ${analysis.llmCalls.length}`);
    report.push(`- Total tokens: ${totalTokens}`);
    report.push('');

    // é”™è¯¯åˆ—è¡¨
    if (analysis.errors.length > 0) {
      report.push('## Errors\n');
      analysis.errors.forEach((error, index) => {
        report.push(`### Error ${index + 1}\n`);
        report.push(`**Time**: ${new Date(error.timestamp).toISOString()}`);
        report.push(`**Message**: ${error.message}`);
        if (error.error) {
          report.push('```');
          report.push(JSON.stringify(error.error, null, 2));
          report.push('```');
        }
        report.push('');
      });
    }

    return report.join('\n');
  }

  // è¾…åŠ©æ–¹æ³•ï¼šåˆ†ç»„
  private groupBy<T>(array: T[], key: string): Record<string, T[]> {
    return array.reduce((result, item) => {
      const groupKey = item[key];
      if (!result[groupKey]) {
        result[groupKey] = [];
      }
      result[groupKey].push(item);
      return result;
    }, {} as Record<string, T[]>);
  }
}
```

## 6. å®æ—¶ç›‘æ§é¢æ¿

### 6.1 ç›‘æ§é¢æ¿ï¼ˆå¯é€‰ï¼‰

```typescript
import blessed from 'blessed';

class MonitoringDashboard {
  private screen: blessed.Widgets.Screen;
  private boxes: {
    status: blessed.Widgets.BoxElement;
    tasks: blessed.Widgets.BoxElement;
    logs: blessed.Widgets.BoxElement;
    stats: blessed.Widgets.BoxElement;
  };

  constructor() {
    this.screen = blessed.screen({
      smartCSR: true,
      title: 'OpenJRAgent Monitor'
    });

    this.createLayout();
    this.setupKeyBindings();
  }

  // åˆ›å»ºå¸ƒå±€
  private createLayout(): void {
    // çŠ¶æ€æ¡†
    this.boxes.status = blessed.box({
      top: 0,
      left: 0,
      width: '50%',
      height: '30%',
      label: ' Status ',
      border: { type: 'line' },
      style: { border: { fg: 'cyan' } }
    });

    // ä»»åŠ¡æ¡†
    this.boxes.tasks = blessed.box({
      top: 0,
      left: '50%',
      width: '50%',
      height: '30%',
      label: ' Tasks ',
      border: { type: 'line' },
      style: { border: { fg: 'cyan' } }
    });

    // æ—¥å¿—æ¡†
    this.boxes.logs = blessed.box({
      top: '30%',
      left: 0,
      width: '100%',
      height: '50%',
      label: ' Logs ',
      border: { type: 'line' },
      style: { border: { fg: 'cyan' } },
      scrollable: true,
      alwaysScroll: true,
      scrollbar: {
        ch: ' ',
        style: { bg: 'blue' }
      }
    });

    // ç»Ÿè®¡æ¡†
    this.boxes.stats = blessed.box({
      top: '80%',
      left: 0,
      width: '100%',
      height: '20%',
      label: ' Statistics ',
      border: { type: 'line' },
      style: { border: { fg: 'cyan' } }
    });

    // æ·»åŠ åˆ°å±å¹•
    this.screen.append(this.boxes.status);
    this.screen.append(this.boxes.tasks);
    this.screen.append(this.boxes.logs);
    this.screen.append(this.boxes.stats);
  }

  // è®¾ç½®å¿«æ·é”®
  private setupKeyBindings(): void {
    this.screen.key(['escape', 'q', 'C-c'], () => {
      process.exit(0);
    });
  }

  // æ›´æ–°çŠ¶æ€
  updateStatus(state: AgentState): void {
    const content = [
      `Phase: ${state.phase}`,
      `Iteration: ${state.currentIteration}/${state.maxIterations}`,
      `Goal: ${state.plan?.goal || 'N/A'}`
    ].join('\n');

    this.boxes.status.setContent(content);
    this.screen.render();
  }

  // æ›´æ–°ä»»åŠ¡åˆ—è¡¨
  updateTasks(tasks: Task[]): void {
    const content = tasks.map((task, index) => {
      const statusIcon = {
        pending: 'â³',
        in_progress: 'ğŸ”„',
        completed: 'âœ…',
        failed: 'âŒ',
        blocked: 'ğŸš«'
      }[task.status];

      return `${index + 1}. ${statusIcon} ${task.title}`;
    }).join('\n');

    this.boxes.tasks.setContent(content);
    this.screen.render();
  }

  // æ·»åŠ æ—¥å¿—
  addLog(entry: LogEntry): void {
    const time = new Date(entry.timestamp).toLocaleTimeString();
    const line = `[${time}] ${entry.level.toUpperCase()}: ${entry.message}`;

    this.boxes.logs.pushLine(line);
    this.boxes.logs.setScrollPerc(100);
    this.screen.render();
  }

  // æ›´æ–°ç»Ÿè®¡
  updateStats(state: AgentState): void {
    const content = [
      `Tokens: ${state.metadata.totalTokens}`,
      `Cost: $${state.metadata.totalCost.toFixed(4)}`,
      `Tool Calls: ${state.metadata.toolCallsCount}`
    ].join(' | ');

    this.boxes.stats.setContent(content);
    this.screen.render();
  }
}
```

## 7. æ—¥å¿—æœ€ä½³å®è·µ

### 7.1 æ—¥å¿—çº§åˆ«ä½¿ç”¨æŒ‡å—

- **DEBUG**: è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯ï¼ˆLLM è¯·æ±‚/å“åº”ã€å·¥å…·å‚æ•°ï¼‰
- **INFO**: ä¸€èˆ¬ä¿¡æ¯ï¼ˆé˜¶æ®µå˜åŒ–ã€ä»»åŠ¡å¼€å§‹/å®Œæˆï¼‰
- **WARN**: è­¦å‘Šä¿¡æ¯ï¼ˆé‡è¯•ã€é™çº§å¤„ç†ï¼‰
- **ERROR**: é”™è¯¯ä¿¡æ¯ï¼ˆå·¥å…·å¤±è´¥ã€LLM é”™è¯¯ï¼‰

### 7.2 ç»“æ„åŒ–æ—¥å¿—ç¤ºä¾‹

```typescript
// å¥½çš„æ—¥å¿—
logger.info('Task started', {
  type: 'task_start',
  taskId: task.id,
  taskTitle: task.title,
  iteration: state.currentIteration
});

// ä¸å¥½çš„æ—¥å¿—
logger.info(`Starting task ${task.id}`);
```

### 7.3 æ€§èƒ½è€ƒè™‘

```typescript
// å¼‚æ­¥æ—¥å¿—å†™å…¥
logger.info('Message', data); // ä¸é˜»å¡

// æ‰¹é‡æ—¥å¿—ï¼ˆé«˜é¢‘åœºæ™¯ï¼‰
const batch = new LogBatch();
for (const item of items) {
  batch.add('Processing item', { item });
}
await batch.flush();
```

## 8. CLI å‘½ä»¤

### 8.1 æ—¥å¿—æŸ¥çœ‹å‘½ä»¤

```bash
# æŸ¥çœ‹æœ€è¿‘çš„æ—¥å¿—
openjragent logs --tail 50

# æŸ¥çœ‹ç‰¹å®šä¼šè¯çš„æ—¥å¿—
openjragent logs --session session-123456

# è¿‡æ»¤æ—¥å¿—çº§åˆ«
openjragent logs --level error

# ç”ŸæˆæŠ¥å‘Š
openjragent report --session session-123456 --format markdown

# åˆ†ææ—¥å¿—
openjragent analyze --log logs/combined.log
```

### 8.2 å®æ—¶ç›‘æ§

```bash
# å¯åŠ¨ç›‘æ§é¢æ¿
openjragent monitor

# è·Ÿè¸ªæ—¥å¿—
openjragent logs --follow
```
