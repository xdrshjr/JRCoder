# 03-工具系统架构设计

## 1. 工具系统概述

工具系统是 Agent 与外部环境交互的核心接口，提供标准化的能力抽象，使 LLM 能够执行具体操作。

### 1.1 设计目标
- **标准化接口**: 统一的工具定义和调用方式
- **类型安全**: 参数验证和类型检查
- **可扩展性**: 易于添加新工具
- **安全性**: 危险操作需确认，文件操作受限
- **可观测性**: 完整的调用日志

### 1.2 工具分类

| 类别 | 工具 | 用途 |
|------|------|------|
| 代码查询 | code_query | 搜索函数、类、文件 |
| 文件操作 | file_read, file_write, file_list | 读写文件、列出目录 |
| 代码片段 | snippet_save, snippet_load, snippet_list | 管理可复用代码片段 |
| Shell | shell_exec | 执行命令行命令 |
| 交互 | ask_user | 向用户提问 |

## 2. 工具基类设计

### 2.1 BaseTool 抽象类

```typescript
abstract class BaseTool {
  // 工具元信息
  abstract readonly name: string;
  abstract readonly description: string;
  abstract readonly parameters: ToolParameter[];

  // 是否为危险操作（需要用户确认）
  readonly dangerous: boolean = false;

  // 执行工具（子类实现）
  abstract execute(args: Record<string, any>): Promise<ToolResult>;

  // 参数验证
  validate(args: Record<string, any>): ValidationResult {
    const errors: string[] = [];

    for (const param of this.parameters) {
      // 检查必需参数
      if (param.required && !(param.name in args)) {
        errors.push(`Missing required parameter: ${param.name}`);
        continue;
      }

      // 检查参数类型
      if (param.name in args) {
        const value = args[param.name];
        const actualType = Array.isArray(value) ? 'array' : typeof value;

        if (actualType !== param.type && value !== null) {
          errors.push(
            `Parameter '${param.name}' expected ${param.type}, got ${actualType}`
          );
        }

        // 检查枚举值
        if (param.enum && !param.enum.includes(value)) {
          errors.push(
            `Parameter '${param.name}' must be one of: ${param.enum.join(', ')}`
          );
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  // 获取工具定义（用于 LLM Function Calling）
  getDefinition(): ToolDefinition {
    return {
      name: this.name,
      description: this.description,
      parameters: {
        type: 'object',
        properties: this.parameters.reduce((acc, param) => {
          acc[param.name] = {
            type: param.type,
            description: param.description,
            enum: param.enum
          };
          return acc;
        }, {} as Record<string, any>),
        required: this.parameters
          .filter(p => p.required)
          .map(p => p.name)
      }
    };
  }
}
```

## 3. 标准工具实现

### 3.1 CodeQueryTool - 代码查询

```typescript
class CodeQueryTool extends BaseTool {
  readonly name = 'code_query';
  readonly description = '在代码库中搜索函数、类、变量或文件';
  readonly parameters: ToolParameter[] = [
    {
      name: 'query',
      type: 'string',
      description: '搜索关键词（函数名、类名、文件名等）',
      required: true
    },
    {
      name: 'type',
      type: 'string',
      description: '搜索类型',
      required: false,
      enum: ['function', 'class', 'variable', 'file', 'all'],
      default: 'all'
    },
    {
      name: 'path',
      type: 'string',
      description: '限制搜索路径',
      required: false
    }
  ];

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { query, type = 'all', path } = args;

    try {
      // 使用 ripgrep 或 AST 解析进行代码搜索
      const results = await this.searchCode(query, type, path);

      return {
        success: true,
        data: {
          query,
          type,
          matches: results.map(r => ({
            file: r.file,
            line: r.line,
            column: r.column,
            code: r.code,
            context: r.context
          }))
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  private async searchCode(
    query: string,
    type: string,
    path?: string
  ): Promise<SearchResult[]> {
    // 实现代码搜索逻辑
    // 可以使用 ripgrep、tree-sitter 等工具
    // ...
  }
}
```

### 3.2 FileReadTool - 文件读取

```typescript
class FileReadTool extends BaseTool {
  readonly name = 'file_read';
  readonly description = '读取文件内容';
  readonly parameters: ToolParameter[] = [
    {
      name: 'path',
      type: 'string',
      description: '文件路径（相对于工作目录）',
      required: true
    },
    {
      name: 'encoding',
      type: 'string',
      description: '文件编码',
      required: false,
      enum: ['utf8', 'ascii', 'base64'],
      default: 'utf8'
    }
  ];

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { path, encoding = 'utf8' } = args;

    try {
      // 安全检查：确保路径在工作目录内
      const safePath = this.validatePath(path);

      // 读取文件
      const content = await fs.readFile(safePath, encoding);

      return {
        success: true,
        data: {
          path,
          content,
          size: content.length,
          encoding
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to read file: ${error.message}`
      };
    }
  }

  private validatePath(path: string): string {
    const workspaceDir = config.tools.workspaceDir;
    const absolutePath = pathModule.resolve(workspaceDir, path);

    // 确保路径在工作目录内（防止路径遍历攻击）
    if (!absolutePath.startsWith(pathModule.resolve(workspaceDir))) {
      throw new Error('Path is outside workspace directory');
    }

    return absolutePath;
  }
}
```

### 3.3 FileWriteTool - 文件写入

```typescript
class FileWriteTool extends BaseTool {
  readonly name = 'file_write';
  readonly description = '写入或创建文件';
  readonly dangerous = true; // 标记为危险操作
  readonly parameters: ToolParameter[] = [
    {
      name: 'path',
      type: 'string',
      description: '文件路径',
      required: true
    },
    {
      name: 'content',
      type: 'string',
      description: '文件内容',
      required: true
    },
    {
      name: 'mode',
      type: 'string',
      description: '写入模式',
      required: false,
      enum: ['overwrite', 'append'],
      default: 'overwrite'
    }
  ];

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { path, content, mode = 'overwrite' } = args;

    try {
      const safePath = this.validatePath(path);

      // 确保目录存在
      await fs.mkdir(pathModule.dirname(safePath), { recursive: true });

      // 写入文件
      if (mode === 'append') {
        await fs.appendFile(safePath, content, 'utf8');
      } else {
        await fs.writeFile(safePath, content, 'utf8');
      }

      return {
        success: true,
        data: {
          path,
          size: content.length,
          mode
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to write file: ${error.message}`
      };
    }
  }

  private validatePath(path: string): string {
    // 同 FileReadTool
    // ...
  }
}
```

### 3.4 FileListTool - 文件列表

```typescript
class FileListTool extends BaseTool {
  readonly name = 'file_list';
  readonly description = '列出目录中的文件和子目录';
  readonly parameters: ToolParameter[] = [
    {
      name: 'path',
      type: 'string',
      description: '目录路径',
      required: false,
      default: '.'
    },
    {
      name: 'recursive',
      type: 'boolean',
      description: '是否递归列出子目录',
      required: false,
      default: false
    },
    {
      name: 'pattern',
      type: 'string',
      description: '文件名匹配模式（glob）',
      required: false
    }
  ];

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { path = '.', recursive = false, pattern } = args;

    try {
      const safePath = this.validatePath(path);
      const files = await this.listFiles(safePath, recursive, pattern);

      return {
        success: true,
        data: {
          path,
          files: files.map(f => ({
            name: f.name,
            path: f.path,
            type: f.isDirectory ? 'directory' : 'file',
            size: f.size,
            modified: f.mtime
          }))
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to list files: ${error.message}`
      };
    }
  }

  private async listFiles(
    dirPath: string,
    recursive: boolean,
    pattern?: string
  ): Promise<FileInfo[]> {
    // 实现文件列表逻辑
    // 使用 fs.readdir 或 glob 库
    // ...
  }
}
```

### 3.5 SnippetSaveTool - 保存代码片段

```typescript
class SnippetSaveTool extends BaseTool {
  readonly name = 'snippet_save';
  readonly description = '保存代码片段以便后续复用';
  readonly parameters: ToolParameter[] = [
    {
      name: 'name',
      type: 'string',
      description: '片段名称（唯一标识）',
      required: true
    },
    {
      name: 'code',
      type: 'string',
      description: '代码内容',
      required: true
    },
    {
      name: 'description',
      type: 'string',
      description: '片段描述',
      required: false
    },
    {
      name: 'language',
      type: 'string',
      description: '编程语言',
      required: false
    },
    {
      name: 'tags',
      type: 'array',
      description: '标签列表',
      required: false
    }
  ];

  constructor(private storage: ISnippetStorage) {
    super();
  }

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { name, code, description, language, tags = [] } = args;

    try {
      const snippet: CodeSnippet = {
        id: generateId(),
        name,
        code,
        description: description || '',
        language: language || 'plaintext',
        tags,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };

      await this.storage.save(snippet);

      return {
        success: true,
        data: {
          id: snippet.id,
          name: snippet.name
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to save snippet: ${error.message}`
      };
    }
  }
}
```

### 3.6 SnippetLoadTool - 加载代码片段

```typescript
class SnippetLoadTool extends BaseTool {
  readonly name = 'snippet_load';
  readonly description = '加载已保存的代码片段';
  readonly parameters: ToolParameter[] = [
    {
      name: 'name',
      type: 'string',
      description: '片段名称或ID',
      required: true
    }
  ];

  constructor(private storage: ISnippetStorage) {
    super();
  }

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { name } = args;

    try {
      const snippet = await this.storage.load(name);

      if (!snippet) {
        return {
          success: false,
          error: `Snippet '${name}' not found`
        };
      }

      return {
        success: true,
        data: {
          id: snippet.id,
          name: snippet.name,
          code: snippet.code,
          description: snippet.description,
          language: snippet.language,
          tags: snippet.tags
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to load snippet: ${error.message}`
      };
    }
  }
}
```

### 3.7 SnippetListTool - 列出代码片段

```typescript
class SnippetListTool extends BaseTool {
  readonly name = 'snippet_list';
  readonly description = '列出所有已保存的代码片段';
  readonly parameters: ToolParameter[] = [
    {
      name: 'tags',
      type: 'array',
      description: '按标签过滤',
      required: false
    },
    {
      name: 'language',
      type: 'string',
      description: '按语言过滤',
      required: false
    }
  ];

  constructor(private storage: ISnippetStorage) {
    super();
  }

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { tags, language } = args;

    try {
      const snippets = await this.storage.list({ tags, language });

      return {
        success: true,
        data: {
          count: snippets.length,
          snippets: snippets.map(s => ({
            id: s.id,
            name: s.name,
            description: s.description,
            language: s.language,
            tags: s.tags,
            createdAt: s.createdAt
          }))
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to list snippets: ${error.message}`
      };
    }
  }
}
```

### 3.8 ShellExecTool - Shell 命令执行

```typescript
class ShellExecTool extends BaseTool {
  readonly name = 'shell_exec';
  readonly description = '执行 Shell 命令';
  readonly dangerous = true; // 危险操作
  readonly parameters: ToolParameter[] = [
    {
      name: 'command',
      type: 'string',
      description: '要执行的命令',
      required: true
    },
    {
      name: 'cwd',
      type: 'string',
      description: '工作目录',
      required: false
    },
    {
      name: 'timeout',
      type: 'number',
      description: '超时时间（毫秒）',
      required: false,
      default: 30000
    }
  ];

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { command, cwd, timeout = 30000 } = args;

    try {
      // 安全检查：禁止某些危险命令
      this.validateCommand(command);

      // 执行命令
      const result = await this.execCommand(command, cwd, timeout);

      return {
        success: true,
        data: {
          command,
          stdout: result.stdout,
          stderr: result.stderr,
          exitCode: result.exitCode
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Command execution failed: ${error.message}`
      };
    }
  }

  private validateCommand(command: string): void {
    // 禁止的危险命令模式
    const dangerousPatterns = [
      /rm\s+-rf\s+\//,  // rm -rf /
      /:\(\)\{.*\}/,     // Fork bomb
      /mkfs/,            // 格式化磁盘
      /dd\s+if=/         // 磁盘操作
    ];

    for (const pattern of dangerousPatterns) {
      if (pattern.test(command)) {
        throw new Error('Dangerous command detected and blocked');
      }
    }
  }

  private async execCommand(
    command: string,
    cwd?: string,
    timeout?: number
  ): Promise<ExecResult> {
    return new Promise((resolve, reject) => {
      const child = exec(command, {
        cwd: cwd || process.cwd(),
        timeout,
        maxBuffer: 10 * 1024 * 1024 // 10MB
      }, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve({
            stdout: stdout.toString(),
            stderr: stderr.toString(),
            exitCode: 0
          });
        }
      });
    });
  }
}
```

### 3.9 AskUserTool - 用户交互

```typescript
class AskUserTool extends BaseTool {
  readonly name = 'ask_user';
  readonly description = '向用户提问以获取更多信息';
  readonly parameters: ToolParameter[] = [
    {
      name: 'question',
      type: 'string',
      description: '要问用户的问题',
      required: true
    },
    {
      name: 'options',
      type: 'array',
      description: '可选的答案选项',
      required: false
    }
  ];

  async execute(args: Record<string, any>): Promise<ToolResult> {
    const { question, options } = args;

    try {
      let answer: string;

      if (options && options.length > 0) {
        // 多选题
        const response = await inquirer.prompt([
          {
            type: 'list',
            name: 'answer',
            message: question,
            choices: options
          }
        ]);
        answer = response.answer;
      } else {
        // 开放式问题
        const response = await inquirer.prompt([
          {
            type: 'input',
            name: 'answer',
            message: question
          }
        ]);
        answer = response.answer;
      }

      return {
        success: true,
        data: {
          question,
          answer
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to get user input: ${error.message}`
      };
    }
  }
}
```

## 4. 工具管理器

### 4.1 ToolManager 实现

```typescript
class ToolManager {
  private tools: Map<string, BaseTool> = new Map();
  private logger: ILogger;

  constructor(
    config: GlobalConfig['tools'],
    logger: ILogger
  ) {
    this.logger = logger;
    this.registerDefaultTools(config);
  }

  // 注册默认工具
  private registerDefaultTools(config: GlobalConfig['tools']): void {
    const snippetStorage = new FileSnippetStorage(config.workspaceDir);

    const defaultTools: BaseTool[] = [
      new CodeQueryTool(),
      new FileReadTool(),
      new FileWriteTool(),
      new FileListTool(),
      new SnippetSaveTool(snippetStorage),
      new SnippetLoadTool(snippetStorage),
      new SnippetListTool(snippetStorage),
      new ShellExecTool(),
      new AskUserTool()
    ];

    for (const tool of defaultTools) {
      if (config.enabled.includes(tool.name)) {
        this.register(tool);
      }
    }
  }

  // 注册工具
  register(tool: BaseTool): void {
    if (this.tools.has(tool.name)) {
      throw new Error(`Tool '${tool.name}' already registered`);
    }

    this.tools.set(tool.name, tool);
    this.logger.info(`Tool registered: ${tool.name}`);
  }

  // 获取工具
  getTool(name: string): BaseTool {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Tool '${name}' not found`);
    }
    return tool;
  }

  // 获取所有工具定义（用于 LLM）
  getDefinitions(): ToolDefinition[] {
    return Array.from(this.tools.values()).map(tool => tool.getDefinition());
  }

  // 执行工具
  async execute(toolCall: ToolCall): Promise<ToolResult> {
    const tool = this.getTool(toolCall.name);

    // 验证参数
    const validation = tool.validate(toolCall.arguments);
    if (!validation.valid) {
      return {
        success: false,
        error: `Validation failed: ${validation.errors.join(', ')}`
      };
    }

    // 记录工具调用
    this.logger.logToolCall(toolCall.name, toolCall.arguments);

    // 执行工具
    const startTime = Date.now();
    try {
      const result = await tool.execute(toolCall.arguments);
      const executionTime = Date.now() - startTime;

      // 记录结果
      this.logger.logToolResult(toolCall.name, result);

      return {
        ...result,
        metadata: {
          ...result.metadata,
          executionTime
        }
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.logger.error(`Tool execution error: ${toolCall.name}`, error);

      return {
        success: false,
        error: error.message,
        metadata: { executionTime }
      };
    }
  }

  // 批量执行工具（并行）
  async executeMany(toolCalls: ToolCall[]): Promise<ToolResult[]> {
    return Promise.all(toolCalls.map(call => this.execute(call)));
  }
}
```

## 5. 工具安全机制

### 5.1 路径验证

```typescript
class PathValidator {
  static validate(path: string, workspaceDir: string): string {
    const absolutePath = pathModule.resolve(workspaceDir, path);
    const normalizedWorkspace = pathModule.resolve(workspaceDir);

    // 防止路径遍历攻击
    if (!absolutePath.startsWith(normalizedWorkspace)) {
      throw new SecurityError('Path is outside workspace directory');
    }

    return absolutePath;
  }
}
```

### 5.2 命令白名单

```typescript
class CommandValidator {
  private static readonly ALLOWED_COMMANDS = [
    'ls', 'cat', 'grep', 'find', 'git',
    'npm', 'yarn', 'node', 'python', 'pip'
  ];

  static validate(command: string): void {
    const baseCommand = command.split(' ')[0];

    if (!this.ALLOWED_COMMANDS.includes(baseCommand)) {
      throw new SecurityError(`Command '${baseCommand}' is not allowed`);
    }
  }
}
```

### 5.3 文件大小限制

```typescript
class FileSizeValidator {
  static async validate(path: string, maxSize: number): Promise<void> {
    const stats = await fs.stat(path);

    if (stats.size > maxSize) {
      throw new ValidationError(
        `File size (${stats.size}) exceeds limit (${maxSize})`
      );
    }
  }
}
```

## 6. 工具扩展机制

### 6.1 自定义工具示例

```typescript
// 用户可以创建自定义工具
class CustomAPITool extends BaseTool {
  readonly name = 'custom_api_call';
  readonly description = '调用自定义 API';
  readonly parameters: ToolParameter[] = [
    {
      name: 'endpoint',
      type: 'string',
      description: 'API 端点',
      required: true
    },
    {
      name: 'method',
      type: 'string',
      description: 'HTTP 方法',
      required: false,
      enum: ['GET', 'POST', 'PUT', 'DELETE'],
      default: 'GET'
    },
    {
      name: 'data',
      type: 'object',
      description: '请求数据',
      required: false
    }
  ];

  async execute(args: Record<string, any>): Promise<ToolResult> {
    // 实现自定义逻辑
    // ...
  }
}

// 注册自定义工具
toolManager.register(new CustomAPITool());
```

### 6.2 工具插件系统

```typescript
interface ToolPlugin {
  name: string;
  version: string;
  tools: BaseTool[];
}

class PluginManager {
  private plugins: Map<string, ToolPlugin> = new Map();

  async loadPlugin(pluginPath: string): Promise<void> {
    const plugin = await import(pluginPath);

    if (!this.validatePlugin(plugin)) {
      throw new Error('Invalid plugin format');
    }

    this.plugins.set(plugin.name, plugin);

    // 注册插件中的所有工具
    for (const tool of plugin.tools) {
      toolManager.register(tool);
    }
  }

  private validatePlugin(plugin: any): plugin is ToolPlugin {
    return (
      typeof plugin.name === 'string' &&
      typeof plugin.version === 'string' &&
      Array.isArray(plugin.tools)
    );
  }
}
```

## 7. 工具使用最佳实践

### 7.1 工具选择策略

```typescript
// Executor 应该根据任务选择合适的工具
const toolSelectionGuide = {
  '查找代码': 'code_query',
  '读取文件': 'file_read',
  '修改文件': 'file_write',
  '列出文件': 'file_list',
  '保存代码': 'snippet_save',
  '执行命令': 'shell_exec',
  '询问用户': 'ask_user'
};
```

### 7.2 错误处理

```typescript
// 工具调用失败时的处理策略
async function handleToolError(
  toolName: string,
  error: Error,
  retryCount: number
): Promise<ToolResult> {
  if (retryCount < 3) {
    // 重试
    await sleep(1000 * retryCount);
    return toolManager.execute({ name: toolName, ... });
  } else {
    // 降级处理
    if (toolName === 'code_query') {
      // 降级到 file_list + file_read
      return fallbackToFileSearch();
    }
    throw error;
  }
}
```

### 7.3 性能优化

```typescript
// 批量文件操作优化
async function optimizedFileOperations(files: string[]): Promise<void> {
  // 并行读取多个文件
  const contents = await Promise.all(
    files.map(file => toolManager.execute({
      name: 'file_read',
      arguments: { path: file }
    }))
  );

  // 处理内容...
}
```
