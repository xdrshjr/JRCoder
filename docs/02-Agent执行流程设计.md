# 02-Agentæ‰§è¡Œæµç¨‹è®¾è®¡

## 1. æ€»ä½“æ‰§è¡Œæµç¨‹

```
ç”¨æˆ·è¾“å…¥ä»»åŠ¡
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¸»å¾ªç¯å¼€å§‹                            â”‚
â”‚  (æœ€å¤š maxIterations æ¬¡è¿­ä»£)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 1: Planning (è§„åˆ’é˜¶æ®µ)                           â”‚
â”‚  - Planner åˆ†æä»»åŠ¡                                      â”‚
â”‚  - åˆ¤æ–­æ˜¯å¦éœ€è¦ TODO åˆ—è¡¨                                â”‚
â”‚  - ç”Ÿæˆæ‰§è¡Œè®¡åˆ’æˆ–ç›´æ¥å›ç­”                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
    â”œâ”€â†’ [ç®€å•ä»»åŠ¡] â†’ ç›´æ¥è¿”å›ç­”æ¡ˆ â†’ ç»“æŸ
    â”‚
    â””â”€â†’ [å¤æ‚ä»»åŠ¡] â†’ ç”Ÿæˆ Plan
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 2: User Confirmation (ç”¨æˆ·ç¡®è®¤)                  â”‚
â”‚  - å±•ç¤ºæ‰§è¡Œè®¡åˆ’                                          â”‚
â”‚  - ç­‰å¾…ç”¨æˆ·ç¡®è®¤/ä¿®æ”¹/å–æ¶ˆ                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
    â”œâ”€â†’ [å–æ¶ˆ] â†’ ç»“æŸ
    â”œâ”€â†’ [ä¿®æ”¹] â†’ è¿”å› Planning
    â””â”€â†’ [ç¡®è®¤] â†’ ç»§ç»­
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 3: Executing (æ‰§è¡Œé˜¶æ®µ)                          â”‚
â”‚  - Executor é€ä¸ªæ‰§è¡Œä»»åŠ¡                                 â”‚
â”‚  - è°ƒç”¨å·¥å…·å®Œæˆå…·ä½“æ“ä½œ                                  â”‚
â”‚  - æ›´æ–°ä»»åŠ¡çŠ¶æ€                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 4: Reflecting (åæ€é˜¶æ®µ)                         â”‚
â”‚  - Reflector è¯„ä¼°æ‰§è¡Œç»“æœ                                â”‚
â”‚  - åˆ¤æ–­æ˜¯å¦è¾¾æˆç›®æ ‡                                      â”‚
â”‚  - è¯†åˆ«é—®é¢˜å¹¶æå‡ºæ”¹è¿›å»ºè®®                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
    â”œâ”€â†’ [ç›®æ ‡è¾¾æˆ] â†’ ç”Ÿæˆæ€»ç»“æŠ¥å‘Š â†’ ç»“æŸ
    â”œâ”€â†’ [éœ€è¦æ”¹è¿›] â†’ ç”Ÿæˆæ–°è®¡åˆ’ â†’ è¿”å› Phase 2
    â””â”€â†’ [é‡åˆ°é˜»å¡] â†’ è¯¢é—®ç”¨æˆ· â†’ æ ¹æ®åé¦ˆå†³å®š
                                      â†“
                        â”œâ”€â†’ [ç»§ç»­] â†’ è¿”å› Planning
                        â””â”€â†’ [ç»ˆæ­¢] â†’ ç»“æŸ
```

## 2. Planner (è§„åˆ’å™¨) è¯¦ç»†æµç¨‹

### 2.1 Planner èŒè´£
- åˆ†æç”¨æˆ·ä»»åŠ¡çš„å¤æ‚åº¦
- åˆ¤æ–­æ˜¯å¦éœ€è¦ç”Ÿæˆ TODO åˆ—è¡¨
- å°†å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºå¯æ‰§è¡Œçš„å­ä»»åŠ¡
- è¯†åˆ«ä»»åŠ¡ä¾èµ–å…³ç³»

### 2.2 Planner æ‰§è¡Œæµç¨‹

```typescript
async function plannerPhase(userTask: string, context: AgentState): Promise<PlannerResult> {
  // 1. æ„å»º Planner æç¤ºè¯
  const prompt = buildPlannerPrompt(userTask, context);

  // 2. è°ƒç”¨ LLM (Planner æ¨¡å‹)
  const response = await plannerLLM.chat({
    messages: [
      { role: 'system', content: PLANNER_SYSTEM_PROMPT },
      { role: 'user', content: prompt }
    ],
    temperature: 0.7
  });

  // 3. è§£æå“åº”
  const result = parsePlannerResponse(response.content);

  // 4. åˆ¤æ–­ä»»åŠ¡ç±»å‹
  if (result.type === 'simple') {
    // ç®€å•ä»»åŠ¡ï¼šç›´æ¥è¿”å›ç­”æ¡ˆ
    return {
      type: 'direct_answer',
      answer: result.answer
    };
  } else {
    // å¤æ‚ä»»åŠ¡ï¼šç”Ÿæˆæ‰§è¡Œè®¡åˆ’
    return {
      type: 'plan',
      plan: {
        goal: userTask,
        tasks: result.tasks.map((task, index) => ({
          id: generateId(),
          title: task.title,
          description: task.description,
          status: 'pending',
          priority: index + 1,
          dependencies: task.dependencies || []
        }))
      }
    };
  }
}
```

### 2.3 Planner æç¤ºè¯æ¨¡æ¿

```typescript
const PLANNER_SYSTEM_PROMPT = `
ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½ä»»åŠ¡è§„åˆ’å™¨ã€‚ä½ çš„èŒè´£æ˜¯ï¼š

1. åˆ†æç”¨æˆ·ä»»åŠ¡çš„å¤æ‚åº¦
2. å¯¹äºç®€å•ä»»åŠ¡ï¼ˆå¦‚æŸ¥è¯¢ã€è§£é‡Šã€ç®€å•é—®ç­”ï¼‰ï¼Œç›´æ¥æä¾›ç­”æ¡ˆ
3. å¯¹äºå¤æ‚ä»»åŠ¡ï¼ˆå¦‚ç¼–ç¨‹ã€å¤šæ­¥éª¤æ“ä½œï¼‰ï¼Œç”Ÿæˆè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’

åˆ¤æ–­æ ‡å‡†ï¼š
- ç®€å•ä»»åŠ¡ï¼šå•æ­¥æ“ä½œã€ä¿¡æ¯æŸ¥è¯¢ã€æ¦‚å¿µè§£é‡Š
- å¤æ‚ä»»åŠ¡ï¼šéœ€è¦å¤šä¸ªæ­¥éª¤ã€æ¶‰åŠä»£ç ä¿®æ”¹ã€éœ€è¦å·¥å…·è°ƒç”¨

è¾“å‡ºæ ¼å¼ï¼š
{
  "type": "simple" | "complex",
  "answer": "ç›´æ¥ç­”æ¡ˆï¼ˆä»…ç®€å•ä»»åŠ¡ï¼‰",
  "tasks": [
    {
      "title": "ä»»åŠ¡æ ‡é¢˜",
      "description": "è¯¦ç»†æè¿°",
      "dependencies": ["ä¾èµ–çš„ä»»åŠ¡ID"]
    }
  ]
}
`;

function buildPlannerPrompt(userTask: string, context: AgentState): string {
  return `
ç”¨æˆ·ä»»åŠ¡ï¼š${userTask}

å½“å‰ä¸Šä¸‹æ–‡ï¼š
- å·²å®Œæˆçš„ä»»åŠ¡ï¼š${context.plan?.tasks.filter(t => t.status === 'completed').length || 0}
- å½“å‰è¿­ä»£ï¼š${context.currentIteration}/${context.maxIterations}

è¯·åˆ†æè¿™ä¸ªä»»åŠ¡å¹¶ç”Ÿæˆæ‰§è¡Œè®¡åˆ’ã€‚
`;
}
```

## 3. Executor (æ‰§è¡Œå™¨) è¯¦ç»†æµç¨‹

### 3.1 Executor èŒè´£
- æŒ‰é¡ºåºæ‰§è¡Œè®¡åˆ’ä¸­çš„ä»»åŠ¡
- è°ƒç”¨åˆé€‚çš„å·¥å…·å®Œæˆå…·ä½“æ“ä½œ
- å¤„ç†å·¥å…·è°ƒç”¨ç»“æœ
- æ›´æ–°ä»»åŠ¡çŠ¶æ€

### 3.2 Executor æ‰§è¡Œæµç¨‹

```typescript
async function executorPhase(plan: Plan, context: AgentState): Promise<ExecutionResult> {
  const results: TaskResult[] = [];

  // 1. è·å–ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œçš„ä»»åŠ¡
  while (true) {
    const nextTask = getNextTask(plan);
    if (!nextTask) break;

    // 2. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸º in_progress
    updateTaskStatus(nextTask.id, 'in_progress');
    logger.info(`å¼€å§‹æ‰§è¡Œä»»åŠ¡: ${nextTask.title}`);

    try {
      // 3. æ„å»º Executor æç¤ºè¯
      const prompt = buildExecutorPrompt(nextTask, context);

      // 4. è°ƒç”¨ LLM (Executor æ¨¡å‹) å¹¶æä¾›å·¥å…·
      const response = await executorLLM.chat({
        messages: [
          { role: 'system', content: EXECUTOR_SYSTEM_PROMPT },
          ...context.conversation.messages,
          { role: 'user', content: prompt }
        ],
        tools: toolManager.getDefinitions(),
        temperature: 0.3
      });

      // 5. å¤„ç†å·¥å…·è°ƒç”¨
      if (response.toolCalls && response.toolCalls.length > 0) {
        const toolResults = await executeTools(response.toolCalls);

        // 6. å°†å·¥å…·ç»“æœåé¦ˆç»™ LLM
        const finalResponse = await executorLLM.chat({
          messages: [
            ...context.conversation.messages,
            { role: 'assistant', content: response.content, toolCalls: response.toolCalls },
            ...toolResults.map(r => ({ role: 'tool', ...r }))
          ],
          temperature: 0.3
        });

        // 7. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸º completed
        updateTaskStatus(nextTask.id, 'completed', {
          result: finalResponse.content,
          toolCalls: response.toolCalls.length
        });

        results.push({
          taskId: nextTask.id,
          success: true,
          output: finalResponse.content
        });
      } else {
        // æ— å·¥å…·è°ƒç”¨ï¼Œç›´æ¥å®Œæˆ
        updateTaskStatus(nextTask.id, 'completed', {
          result: response.content
        });

        results.push({
          taskId: nextTask.id,
          success: true,
          output: response.content
        });
      }

    } catch (error) {
      // 8. å¤„ç†é”™è¯¯
      logger.error(`ä»»åŠ¡æ‰§è¡Œå¤±è´¥: ${nextTask.title}`, error);
      updateTaskStatus(nextTask.id, 'failed', { error: error.message });

      results.push({
        taskId: nextTask.id,
        success: false,
        error: error.message
      });

      // å¦‚æœæ˜¯å…³é”®ä»»åŠ¡å¤±è´¥ï¼Œç»ˆæ­¢æ‰§è¡Œ
      if (nextTask.priority <= 2) {
        break;
      }
    }
  }

  return {
    completedTasks: results.filter(r => r.success).length,
    failedTasks: results.filter(r => !r.success).length,
    results
  };
}
```

### 3.3 å·¥å…·è°ƒç”¨å¤„ç†

```typescript
async function executeTools(toolCalls: ToolCall[]): Promise<ToolResultMessage[]> {
  const results: ToolResultMessage[] = [];

  for (const toolCall of toolCalls) {
    logger.logToolCall(toolCall.name, toolCall.arguments);

    try {
      // 1. è·å–å·¥å…·å®ä¾‹
      const tool = toolManager.getTool(toolCall.name);

      // 2. éªŒè¯å‚æ•°
      const validation = tool.validate(toolCall.arguments);
      if (!validation.valid) {
        throw new ValidationError(`Invalid arguments: ${validation.errors.join(', ')}`);
      }

      // 3. æ£€æŸ¥æ˜¯å¦éœ€è¦ç”¨æˆ·ç¡®è®¤
      if (tool.dangerous && config.cli.confirmDangerous) {
        const confirmed = await askUserConfirmation(
          `å·¥å…· '${toolCall.name}' å°†æ‰§è¡Œå±é™©æ“ä½œï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`,
          toolCall.arguments
        );

        if (!confirmed) {
          results.push({
            role: 'tool',
            toolCallId: toolCall.id,
            toolName: toolCall.name,
            content: 'User cancelled the operation',
            error: 'Operation cancelled by user'
          });
          continue;
        }
      }

      // 4. æ‰§è¡Œå·¥å…·
      const startTime = Date.now();
      const result = await tool.execute(toolCall.arguments);
      const executionTime = Date.now() - startTime;

      logger.logToolResult(toolCall.name, result);

      // 5. æ„å»ºç»“æœæ¶ˆæ¯
      results.push({
        role: 'tool',
        toolCallId: toolCall.id,
        toolName: toolCall.name,
        content: JSON.stringify(result.data),
        timestamp: Date.now(),
        metadata: { executionTime }
      });

    } catch (error) {
      logger.error(`Tool execution failed: ${toolCall.name}`, error);

      results.push({
        role: 'tool',
        toolCallId: toolCall.id,
        toolName: toolCall.name,
        content: '',
        error: error.message,
        timestamp: Date.now()
      });
    }
  }

  return results;
}
```

### 3.4 Executor æç¤ºè¯æ¨¡æ¿

```typescript
const EXECUTOR_SYSTEM_PROMPT = `
ä½ æ˜¯ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œå™¨ã€‚ä½ çš„èŒè´£æ˜¯ï¼š

1. ç†è§£å½“å‰ä»»åŠ¡çš„ç›®æ ‡
2. é€‰æ‹©åˆé€‚çš„å·¥å…·å®Œæˆä»»åŠ¡
3. æ­£ç¡®è°ƒç”¨å·¥å…·å¹¶å¤„ç†ç»“æœ
4. å¦‚æœé‡åˆ°é—®é¢˜ï¼Œå°è¯•å…¶ä»–æ–¹æ³•æˆ–æŠ¥å‘Šé”™è¯¯

å¯ç”¨å·¥å…·ï¼š
- code_query: æŸ¥è¯¢ä»£ç åº“ä¸­çš„å‡½æ•°ã€ç±»ã€æ–‡ä»¶
- file_read: è¯»å–æ–‡ä»¶å†…å®¹
- file_write: å†™å…¥æ–‡ä»¶å†…å®¹
- file_list: åˆ—å‡ºç›®å½•ä¸­çš„æ–‡ä»¶
- snippet_save: ä¿å­˜ä»£ç ç‰‡æ®µ
- snippet_load: åŠ è½½ä»£ç ç‰‡æ®µ
- snippet_list: åˆ—å‡ºæ‰€æœ‰ä»£ç ç‰‡æ®µ
- shell_exec: æ‰§è¡Œ Shell å‘½ä»¤
- ask_user: å‘ç”¨æˆ·æé—®

æ³¨æ„äº‹é¡¹ï¼š
- ä¼˜å…ˆä½¿ç”¨ç°æœ‰ä»£ç ï¼Œé¿å…é‡å¤é€ è½®å­
- ä¿®æ”¹æ–‡ä»¶å‰å…ˆè¯»å–å†…å®¹
- æ‰§è¡Œå±é™©æ“ä½œå‰ä¼šæç¤ºç”¨æˆ·ç¡®è®¤
- å¦‚æœä¸ç¡®å®šï¼Œä½¿ç”¨ ask_user å·¥å…·è¯¢é—®ç”¨æˆ·
`;

function buildExecutorPrompt(task: Task, context: AgentState): string {
  return `
å½“å‰ä»»åŠ¡ï¼š${task.title}
ä»»åŠ¡æè¿°ï¼š${task.description}

å·²å®Œæˆçš„ä»»åŠ¡ï¼š
${context.plan.tasks
  .filter(t => t.status === 'completed')
  .map(t => `- ${t.title}`)
  .join('\n')}

è¯·ä½¿ç”¨åˆé€‚çš„å·¥å…·å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚
`;
}
```

## 4. Reflector (åæ€å™¨) è¯¦ç»†æµç¨‹

### 4.1 Reflector èŒè´£
- è¯„ä¼°ä»»åŠ¡æ‰§è¡Œç»“æœ
- åˆ¤æ–­æ˜¯å¦è¾¾æˆç›®æ ‡
- è¯†åˆ«æ‰§è¡Œä¸­çš„é—®é¢˜
- æå‡ºæ”¹è¿›å»ºè®®

### 4.2 Reflector æ‰§è¡Œæµç¨‹

```typescript
async function reflectorPhase(
  plan: Plan,
  executionResult: ExecutionResult,
  context: AgentState
): Promise<ReflectionResult> {

  // 1. æ„å»ºåæ€æç¤ºè¯
  const prompt = buildReflectorPrompt(plan, executionResult, context);

  // 2. è°ƒç”¨ LLM (Reflector æ¨¡å‹)
  const response = await reflectorLLM.chat({
    messages: [
      { role: 'system', content: REFLECTOR_SYSTEM_PROMPT },
      { role: 'user', content: prompt }
    ],
    temperature: 0.5
  });

  // 3. è§£æåæ€ç»“æœ
  const reflection = parseReflectionResponse(response.content);

  // 4. åˆ¤æ–­ä¸‹ä¸€æ­¥è¡ŒåŠ¨
  if (reflection.goalAchieved) {
    return {
      status: 'completed',
      summary: reflection.summary,
      nextAction: 'finish'
    };
  } else if (reflection.blocked) {
    return {
      status: 'blocked',
      issues: reflection.issues,
      nextAction: 'ask_user',
      question: reflection.question
    };
  } else if (context.currentIteration >= context.maxIterations) {
    return {
      status: 'max_iterations_reached',
      summary: reflection.summary,
      nextAction: 'finish'
    };
  } else {
    return {
      status: 'needs_improvement',
      issues: reflection.issues,
      suggestions: reflection.suggestions,
      nextAction: 'replan',
      newPlan: reflection.improvedPlan
    };
  }
}
```

### 4.3 Reflector æç¤ºè¯æ¨¡æ¿

```typescript
const REFLECTOR_SYSTEM_PROMPT = `
ä½ æ˜¯ä¸€ä¸ªåæ€è¯„ä¼°å™¨ã€‚ä½ çš„èŒè´£æ˜¯ï¼š

1. è¯„ä¼°ä»»åŠ¡æ‰§è¡Œç»“æœæ˜¯å¦è¾¾æˆç›®æ ‡
2. è¯†åˆ«æ‰§è¡Œè¿‡ç¨‹ä¸­çš„é—®é¢˜å’Œä¸è¶³
3. æå‡ºå…·ä½“çš„æ”¹è¿›å»ºè®®
4. åˆ¤æ–­æ˜¯å¦éœ€è¦é‡æ–°è§„åˆ’

è¯„ä¼°æ ‡å‡†ï¼š
- ç›®æ ‡è¾¾æˆåº¦ï¼šæ˜¯å¦å®Œæˆäº†ç”¨æˆ·çš„åŸå§‹éœ€æ±‚
- ä»£ç è´¨é‡ï¼šæ˜¯å¦ç¬¦åˆæœ€ä½³å®è·µ
- é”™è¯¯å¤„ç†ï¼šæ˜¯å¦æœ‰æœªå¤„ç†çš„é”™è¯¯
- å®Œæ•´æ€§ï¼šæ˜¯å¦æœ‰é—æ¼çš„åŠŸèƒ½

è¾“å‡ºæ ¼å¼ï¼š
{
  "goalAchieved": true/false,
  "blocked": true/false,
  "summary": "æ‰§è¡Œæ€»ç»“",
  "issues": ["é—®é¢˜1", "é—®é¢˜2"],
  "suggestions": ["å»ºè®®1", "å»ºè®®2"],
  "question": "éœ€è¦è¯¢é—®ç”¨æˆ·çš„é—®é¢˜ï¼ˆå¦‚æœ blockedï¼‰",
  "improvedPlan": { ... } // æ”¹è¿›åçš„è®¡åˆ’ï¼ˆå¦‚æœéœ€è¦ï¼‰
}
`;

function buildReflectorPrompt(
  plan: Plan,
  executionResult: ExecutionResult,
  context: AgentState
): string {
  return `
åŸå§‹ç›®æ ‡ï¼š${plan.goal}

æ‰§è¡Œç»“æœï¼š
- å®Œæˆä»»åŠ¡æ•°ï¼š${executionResult.completedTasks}
- å¤±è´¥ä»»åŠ¡æ•°ï¼š${executionResult.failedTasks}

ä»»åŠ¡è¯¦æƒ…ï¼š
${executionResult.results.map(r => `
- ä»»åŠ¡ID: ${r.taskId}
  çŠ¶æ€: ${r.success ? 'æˆåŠŸ' : 'å¤±è´¥'}
  ${r.success ? `è¾“å‡º: ${r.output}` : `é”™è¯¯: ${r.error}`}
`).join('\n')}

å½“å‰è¿­ä»£ï¼š${context.currentIteration}/${context.maxIterations}

è¯·è¯„ä¼°æ‰§è¡Œç»“æœï¼Œåˆ¤æ–­æ˜¯å¦è¾¾æˆç›®æ ‡ï¼Œå¹¶æå‡ºæ”¹è¿›å»ºè®®ã€‚
`;
}
```

## 5. ç”¨æˆ·ç¡®è®¤æœºåˆ¶

### 5.1 ç¡®è®¤æ—¶æœº
- æ‰§è¡Œè®¡åˆ’ç”Ÿæˆå
- å±é™©å·¥å…·è°ƒç”¨å‰
- é‡åˆ°é˜»å¡éœ€è¦ç”¨æˆ·å†³ç­–æ—¶

### 5.2 ç¡®è®¤æµç¨‹

```typescript
async function userConfirmationPhase(plan: Plan): Promise<ConfirmationResult> {
  // 1. å±•ç¤ºæ‰§è¡Œè®¡åˆ’
  console.log(chalk.bold('\nğŸ“‹ æ‰§è¡Œè®¡åˆ’ï¼š\n'));
  console.log(chalk.cyan(`ç›®æ ‡: ${plan.goal}\n`));

  plan.tasks.forEach((task, index) => {
    console.log(chalk.white(`${index + 1}. ${task.title}`));
    console.log(chalk.gray(`   ${task.description}`));
    if (task.dependencies.length > 0) {
      console.log(chalk.yellow(`   ä¾èµ–: ${task.dependencies.join(', ')}`));
    }
  });

  // 2. è¯¢é—®ç”¨æˆ·
  const answer = await inquirer.prompt([
    {
      type: 'list',
      name: 'action',
      message: 'è¯·é€‰æ‹©æ“ä½œï¼š',
      choices: [
        { name: 'âœ… ç¡®è®¤æ‰§è¡Œ', value: 'confirm' },
        { name: 'âœï¸  ä¿®æ”¹è®¡åˆ’', value: 'modify' },
        { name: 'âŒ å–æ¶ˆ', value: 'cancel' }
      ]
    }
  ]);

  // 3. å¤„ç†ç”¨æˆ·é€‰æ‹©
  switch (answer.action) {
    case 'confirm':
      return { action: 'proceed' };

    case 'modify':
      const modifications = await inquirer.prompt([
        {
          type: 'editor',
          name: 'newPlan',
          message: 'è¯·ä¿®æ”¹è®¡åˆ’ï¼ˆJSON æ ¼å¼ï¼‰ï¼š',
          default: JSON.stringify(plan, null, 2)
        }
      ]);

      try {
        const modifiedPlan = JSON.parse(modifications.newPlan);
        return { action: 'replan', plan: modifiedPlan };
      } catch (error) {
        console.log(chalk.red('âŒ è®¡åˆ’æ ¼å¼é”™è¯¯ï¼Œè¯·é‡è¯•'));
        return userConfirmationPhase(plan); // é€’å½’é‡è¯•
      }

    case 'cancel':
      return { action: 'cancel' };
  }
}
```

### 5.3 å±é™©æ“ä½œç¡®è®¤

```typescript
async function askUserConfirmation(
  message: string,
  details?: any
): Promise<boolean> {
  console.log(chalk.yellow(`\nâš ï¸  ${message}\n`));

  if (details) {
    console.log(chalk.gray('è¯¦ç»†ä¿¡æ¯ï¼š'));
    console.log(chalk.gray(JSON.stringify(details, null, 2)));
  }

  const answer = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'confirmed',
      message: 'æ˜¯å¦ç»§ç»­ï¼Ÿ',
      default: false
    }
  ]);

  return answer.confirmed;
}
```

## 6. ä¸»å¾ªç¯æ§åˆ¶å™¨

### 6.1 ä¸»å¾ªç¯ä¼ªä»£ç 

```typescript
async function mainLoop(userTask: string, config: GlobalConfig): Promise<void> {
  // 1. åˆå§‹åŒ–
  const stateManager = new StateManager();
  const logger = new Logger(config.logging);
  const toolManager = new ToolManager(config.tools);

  stateManager.updatePhase('planning');
  logger.info('Agent å¯åŠ¨', { task: userTask });

  try {
    // 2. ä¸»å¾ªç¯
    while (stateManager.state.currentIteration < config.agent.maxIterations) {
      stateManager.incrementIteration();
      logger.info(`å¼€å§‹ç¬¬ ${stateManager.state.currentIteration} æ¬¡è¿­ä»£`);

      // Phase 1: Planning
      stateManager.updatePhase('planning');
      const plannerResult = await plannerPhase(userTask, stateManager.state);

      if (plannerResult.type === 'direct_answer') {
        // ç®€å•ä»»åŠ¡ï¼Œç›´æ¥è¿”å›ç­”æ¡ˆ
        console.log(chalk.green('\nâœ… ç­”æ¡ˆï¼š\n'));
        console.log(plannerResult.answer);
        break;
      }

      // å¤æ‚ä»»åŠ¡ï¼Œè®¾ç½®è®¡åˆ’
      stateManager.setPlan(plannerResult.plan);

      // Phase 2: User Confirmation
      if (config.agent.requireConfirmation) {
        stateManager.updatePhase('confirming');
        const confirmation = await userConfirmationPhase(plannerResult.plan);

        if (confirmation.action === 'cancel') {
          logger.info('ç”¨æˆ·å–æ¶ˆæ‰§è¡Œ');
          break;
        } else if (confirmation.action === 'replan') {
          stateManager.setPlan(confirmation.plan);
        }
      }

      // Phase 3: Executing
      stateManager.updatePhase('executing');
      const executionResult = await executorPhase(
        stateManager.state.plan,
        stateManager.state
      );

      // Phase 4: Reflecting
      if (config.agent.enableReflection) {
        stateManager.updatePhase('reflecting');
        const reflectionResult = await reflectorPhase(
          stateManager.state.plan,
          executionResult,
          stateManager.state
        );

        // æ ¹æ®åæ€ç»“æœå†³å®šä¸‹ä¸€æ­¥
        if (reflectionResult.nextAction === 'finish') {
          console.log(chalk.green('\nâœ… ä»»åŠ¡å®Œæˆï¼\n'));
          console.log(reflectionResult.summary);
          break;
        } else if (reflectionResult.nextAction === 'ask_user') {
          const userResponse = await askUser(reflectionResult.question);
          userTask = `${userTask}\n\nç”¨æˆ·åé¦ˆï¼š${userResponse}`;
          continue; // é‡æ–°è§„åˆ’
        } else if (reflectionResult.nextAction === 'replan') {
          stateManager.setPlan(reflectionResult.newPlan);
          continue; // ç»§ç»­ä¸‹ä¸€æ¬¡è¿­ä»£
        }
      } else {
        // ä¸å¯ç”¨åæ€ï¼Œç›´æ¥å®Œæˆ
        console.log(chalk.green('\nâœ… æ‰§è¡Œå®Œæˆï¼\n'));
        break;
      }
    }

    // 3. è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°
    if (stateManager.state.currentIteration >= config.agent.maxIterations) {
      console.log(chalk.yellow('\nâš ï¸  è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œä»»åŠ¡å¯èƒ½æœªå®Œå…¨å®Œæˆ\n'));
    }

  } catch (error) {
    // 4. é”™è¯¯å¤„ç†
    logger.error('Agent æ‰§è¡Œå¤±è´¥', error);
    console.log(chalk.red(`\nâŒ é”™è¯¯ï¼š${error.message}\n`));
  } finally {
    // 5. æ¸…ç†å’Œä¿å­˜
    stateManager.updatePhase('completed');
    await stateManager.save(`logs/session-${Date.now()}.json`);
    logger.info('Agent ç»“æŸ');
  }
}
```

## 7. çŠ¶æ€è½¬æ¢å›¾

```
[åˆå§‹åŒ–]
    â†“
[planning] â”€â”€â†’ [direct_answer] â”€â”€â†’ [completed]
    â†“
[confirming]
    â†“
    â”œâ”€â”€â†’ [cancel] â”€â”€â†’ [completed]
    â””â”€â”€â†’ [proceed]
            â†“
        [executing]
            â†“
        [reflecting]
            â†“
            â”œâ”€â”€â†’ [goal_achieved] â”€â”€â†’ [completed]
            â”œâ”€â”€â†’ [blocked] â”€â”€â†’ [ask_user] â”€â”€â†’ [planning]
            â”œâ”€â”€â†’ [needs_improvement] â”€â”€â†’ [planning]
            â””â”€â”€â†’ [max_iterations] â”€â”€â†’ [completed]
```

## 8. é”™è¯¯æ¢å¤ç­–ç•¥

### 8.1 å·¥å…·è°ƒç”¨å¤±è´¥
```typescript
// ç­–ç•¥ï¼šé‡è¯• 3 æ¬¡ï¼Œå¤±è´¥åè·³è¿‡æˆ–è¯¢é—®ç”¨æˆ·
if (toolCallFailed) {
  if (retryCount < 3) {
    await sleep(1000 * retryCount);
    retry();
  } else {
    if (task.priority <= 2) {
      // å…³é”®ä»»åŠ¡å¤±è´¥ï¼Œè¯¢é—®ç”¨æˆ·
      await askUser('å…³é”®ä»»åŠ¡å¤±è´¥ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ');
    } else {
      // éå…³é”®ä»»åŠ¡ï¼Œè·³è¿‡
      markTaskAsSkipped(task.id);
    }
  }
}
```

### 8.2 LLM è°ƒç”¨å¤±è´¥
```typescript
// ç­–ç•¥ï¼šæŒ‡æ•°é€€é¿é‡è¯•ï¼Œæœ€å¤š 5 æ¬¡
if (llmCallFailed) {
  if (retryCount < 5) {
    await sleep(Math.pow(2, retryCount) * 1000);
    retry();
  } else {
    throw new LLMError('LLM è°ƒç”¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®');
  }
}
```

### 8.3 ç”¨æˆ·ä¸­æ–­
```typescript
// ç­–ç•¥ï¼šä¿å­˜å½“å‰çŠ¶æ€ï¼Œæ”¯æŒæ¢å¤
process.on('SIGINT', async () => {
  console.log('\nâš ï¸  æ£€æµ‹åˆ°ä¸­æ–­ä¿¡å·ï¼Œæ­£åœ¨ä¿å­˜çŠ¶æ€...');
  await stateManager.save('logs/interrupted-session.json');
  console.log('âœ… çŠ¶æ€å·²ä¿å­˜ï¼Œå¯ä½¿ç”¨ --resume æ¢å¤');
  process.exit(0);
});
```

## 9. æ€§èƒ½ä¼˜åŒ–

### 9.1 å¹¶è¡Œå·¥å…·è°ƒç”¨
```typescript
// å¦‚æœå¤šä¸ªå·¥å…·è°ƒç”¨æ— ä¾èµ–å…³ç³»ï¼Œå¹¶è¡Œæ‰§è¡Œ
const independentCalls = identifyIndependentCalls(toolCalls);
const results = await Promise.all(
  independentCalls.map(call => executeTools([call]))
);
```

### 9.2 ç¼“å­˜æœºåˆ¶
```typescript
// ç¼“å­˜ä»£ç æŸ¥è¯¢ç»“æœï¼Œé¿å…é‡å¤è°ƒç”¨
const cacheKey = `code_query:${JSON.stringify(args)}`;
const cached = cache.get(cacheKey);
if (cached) return cached;

const result = await tool.execute(args);
cache.set(cacheKey, result, { ttl: 300 }); // 5åˆ†é’Ÿè¿‡æœŸ
```

### 9.3 æµå¼è¾“å‡º
```typescript
// å¯¹äºé•¿æ—¶é—´æ‰§è¡Œçš„ä»»åŠ¡ï¼Œä½¿ç”¨æµå¼è¾“å‡ºæå‡ä½“éªŒ
const stream = await executorLLM.chatStream(request);
for await (const chunk of stream) {
  process.stdout.write(chunk);
}
```
